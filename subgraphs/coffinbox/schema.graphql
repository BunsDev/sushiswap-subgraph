type CoffinBox @entity {
  # Contract ID
  id: ID!

  users: [User!] @derivedFrom(field: "coffinBox")
  tokens: [Token!] @derivedFrom(field: "coffinBox")
  underworldPairs: [UnderworldPair!] @derivedFrom(field: "coffinBox")
  transactions: [CoffinBoxAction!] @derivedFrom(field: "coffinBox")
  flashloans: [FlashLoan!] @derivedFrom(field: "coffinBox")
  masterContracts: [MasterContract!] @derivedFrom(field: "coffinBox")
  #protocols

  totalTokens: BigInt!
  totalUnderworldPairs: BigInt!
  totalUsers: BigInt!

  block: BigInt!
  timestamp: BigInt!
}

enum CoffinBoxActionType {
  deposit
  transfer
  withdraw
}

type CoffinBoxAction @entity {
  id: ID!
  coffinBox: CoffinBox!
  type: CoffinBoxActionType!
  from: User!
  to: User!
  token: Token!
  amount: BigInt!
  share: BigInt!
  block: BigInt!
  timestamp: BigInt!
}

type FlashLoan @entity {
  id: ID!
  coffinBox: CoffinBox!
  borrower: Bytes!
  receiver: Bytes!
  token: Token!
  amount: BigInt!
  feeAmount: BigInt!
  block: BigInt!
  timestamp: BigInt!
}

type MasterContract @entity {
  id: ID!
  coffinBox: CoffinBox!
  clones: [Clone!] @derivedFrom(field: "masterContract")
  masterContractApprovals: [MasterContractApproval!] @derivedFrom(field: "masterContract")
}

type Clone @entity {
  id: ID!
  coffinBox: CoffinBox!
  masterContract: MasterContract!
  data: String!
  block: BigInt!
  timestamp: BigInt!
}

type MasterContractApproval @entity {
  # concatenate UserAddress with MasterContract
  id: ID!
  masterContract: MasterContract!
  user: User!
  approved: Boolean!
}

# TODO: Not sure what do with the Protocols that get registered
type Protocol @entity {
  id: ID!
}

type Token @entity {
  id: ID!
  coffinBox: CoffinBox!
  name: String!
  symbol: String!
  decimals: BigInt!
  totalSupplyElastic: BigInt!
  totalSupplyBase: BigInt!
  strategy: Strategy
  strategyTargetPercentage: BigInt!
  block: BigInt!
  timestamp: BigInt!
}

type User @entity {
  id: ID!
  coffinBox: CoffinBox!
  masterContractApprovals: [MasterContractApproval!] @derivedFrom(field: "user")
  tokens: [UserToken!] @derivedFrom(field: "user")
  underworldPairs: [UserUnderworldPair!] @derivedFrom(field: "user")
  withdrawals: [CoffinBoxAction!] @derivedFrom(field: "from")
  deposits: [CoffinBoxAction!] @derivedFrom(field: "to")
  block: BigInt!
  timestamp: BigInt!
}

type UserToken @entity {
  # concatenate UserAddress with TokenAddress
  id: ID!
  user: User!
  token: Token!
  share: BigInt!
  block: BigInt!
  timestamp: BigInt!
}

enum UnderworldPairType {
  medium
}

type UnderworldPair @entity {
  id: ID!
  coffinBox: CoffinBox!
  type: UnderworldPairType!
  masterContract: MasterContract!
  owner: Bytes!
  feeTo: Bytes!
  name: String!
  symbol: String!
  oracle: Bytes!
  asset: Token!
  collateral: Token!
  exchangeRate: BigInt!
  totalAssetElastic: BigInt!
  totalAssetBase: BigInt!
  totalCollateralShare: BigInt!
  totalBorrowElastic: BigInt!
  totalBorrowBase: BigInt!
  interestPerSecond: BigInt!
  utilization: BigInt!
  feesEarnedFraction: BigInt!
  totalFeesEarnedFraction: BigInt!
  lastAccrued: BigInt!
  supplyAPR: BigInt!
  borrowAPR: BigInt!
  transactions: [UnderworldPairAction!] @derivedFrom(field: "pair")
  users: [UserUnderworldPair!] @derivedFrom(field: "pair")
  block: BigInt!
  timestamp: BigInt!
}

enum UnderworldPairActionType {
  addAsset
  removeAsset
  addCollateral
  removeCollateral
  borrow
  repay
}

type UnderworldPairAction @entity {
  id: ID!
  type: UnderworldPairActionType!
  pair: UnderworldPair!
  root: UserUnderworldPair!
  token: Token!
  amount: BigInt
  share: BigInt
  feeAmount: BigInt
  fraction: BigInt
  part: BigInt
  poolPercentage: BigInt!
  block: BigInt!
  timestamp: BigInt!
}

type UserUnderworldPair @entity {
  id: ID!
  user: User!
  pair: UnderworldPair!
  assetFraction: BigInt! #comes from balanceOf on pair contract
  collateralShare: BigInt!
  borrowPart: BigInt!
  transactions: [UnderworldPairAction!] @derivedFrom(field: "root")
  block: BigInt!
  timestamp: BigInt!
}

type UnderworldPairHourData @entity {
  # pair id - hour start timestamp
  id: ID!

  hourStartUnix: Int!

  pair: UnderworldPair!

  totalAssetElastic: BigInt!
  totalAssetBase: BigInt!
  totalCollateralShare: BigInt!
  totalBorrowElastic: BigInt!
  totalBorrowBase: BigInt!

  #hourlyVolumeSupplied
  #hourlyVolumeBorrowed
  #hourlyTxns

  #totalFeesEarnedFraction: BigInt!
  avgExchangeRate: BigInt!
  avgUtilization: BigInt!
  avgInterestPerSecond: BigInt!
  #avgSupplyInterestPerSecond: BigInt!
  #avgBorrowInterestPerSecond: BigInt!
}

type UnderworldPairDayData @entity {
  # pair id - day start timestamp
  id: ID!

  # date - hour start timestamp
  date: Int!

  pair: UnderworldPair!

  totalAssetElastic: BigInt!
  totalAssetBase: BigInt!
  totalCollateralShare: BigInt!
  totalBorrowElastic: BigInt!
  totalBorrowBase: BigInt!

  #hourlyVolumeSupplied
  #hourlyVolumeBorrowed
  #hourlyTxns

  #totalFeesEarnedFraction: BigInt!
  avgExchangeRate: BigInt!
  avgUtilization: BigInt!
  avgInterestPerSecond: BigInt!
  #avgSupplyInterestPerSecond: BigInt!
  #avgBorrowInterestPerSecond: BigInt!
}

type Strategy @entity {
  id: ID!
  token: Token!
  balance: BigInt!
  totalProfit: BigInt!
  harvests: [StrategyHarvest!] @derivedFrom(field: "strategy")
  timestamp: BigInt!
  block: BigInt!
}

type StrategyHarvest @entity {
  id: ID!
  strategy: Strategy!
  profit: BigInt!
  tokenElastic: BigInt!
  timestamp: BigInt!
  block: BigInt!
}